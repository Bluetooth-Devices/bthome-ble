"""Parser for BLE advertisements in BThome format.

This file is shamelessly copied from the following repository:
https://github.com/Ernst79/bleparser/blob/ac8757ad64f1fc17674dcd22111e547cdf2f205b/package/bleparser/ha_ble.py

BThome was originally developed as HA BLE for ble_monitor and been renamed to
BThome for Home Assistant Bluetooth integrations.

MIT License applies.
"""
from __future__ import annotations

import logging
import struct
import sys
from typing import Any

from bluetooth_sensor_state_data import BluetoothData
from Cryptodome.Cipher import AES
from home_assistant_bluetooth import BluetoothServiceInfo
from sensor_state_data import SensorLibrary

_LOGGER = logging.getLogger(__name__)


def short_address(address: str) -> str:
    """Convert a Bluetooth address to a short address"""
    results = address.replace("-", ":").split(":")
    if len(results[-1]) == 2:
        return f"{results[-2].upper()}{results[-1].upper()}"
    return results[-1].upper()


def to_mac(addr: bytes) -> str:
    """Return formatted MAC address"""
    return ":".join(f"{i:02X}" for i in addr)


def parse_uint(data_obj: bytes, factor: float = 1) -> float:
    """convert bytes (as unsigned integer) and factor to float"""
    decimal_places = -int(f"{factor:e}".split("e")[-1])
    return round(
        int.from_bytes(data_obj, "little", signed=False) * factor, decimal_places
    )


def parse_int(data_obj: bytes, factor: float = 1) -> float:
    """convert bytes (as signed integer) and factor to float"""
    decimal_places = -int(f"{factor:e}".split("e")[-1])
    return round(
        int.from_bytes(data_obj, "little", signed=True) * factor, decimal_places
    )


def parse_float(data_obj: bytes, factor: float = 1) -> float | None:
    """convert bytes (as float) and factor to float"""
    decimal_places = -int(f"{factor:e}".split("e")[-1])
    if len(data_obj) == 2:
        [val] = struct.unpack("e", data_obj)
    elif len(data_obj) == 4:
        [val] = struct.unpack("f", data_obj)
    elif len(data_obj) == 8:
        [val] = struct.unpack("d", data_obj)
    else:
        _LOGGER.error("only 2, 4 or 8 byte long floats are supported in BThome BLE")
        return None
    return round(val * factor, decimal_places)


def parse_string(data_obj: bytes) -> str:
    """convert bytes to string"""
    return data_obj.decode("UTF-8")


def parse_mac(data_obj: bytes) -> bytes | None:
    """convert bytes to mac"""
    if len(data_obj) == 6:
        return data_obj[::-1]
    else:
        _LOGGER.error("MAC address has to be 6 bytes long")
        return None


dispatch = {
    0x00: parse_uint,
    0x01: parse_int,
    0x02: parse_float,
}


DATA_MEAS_DICT = {
    0x01: [SensorLibrary.BATTERY__PERCENTAGE, 1],
    0x02: [SensorLibrary.TEMPERATURE__CELSIUS, 0.01],
    0x03: [SensorLibrary.HUMIDITY__PERCENTAGE, 0.01],
    0x04: [SensorLibrary.PRESSURE__MBAR, 0.01],
    0x05: [SensorLibrary.LIGHT__LIGHT_LUX, 0.01],
    0x0A: [SensorLibrary.ENERGY__ENERGY_KILO_WATT_HOUR, 0.001],
    0x0B: [SensorLibrary.POWER__POWER_WATT, 0.01],
    0x0C: [SensorLibrary.VOLTAGE__ELECTRIC_POTENTIAL_VOLT, 0.001],
    0x0D: [SensorLibrary.PM25__CONCENTRATION_MICROGRAMS_PER_CUBIC_METER, 1],
    0x0E: [SensorLibrary.PM10__CONCENTRATION_MICROGRAMS_PER_CUBIC_METER, 1],
    0x12: [SensorLibrary.CO2__CONCENTRATION_PARTS_PER_MILLION, 1],
    0x13: [
        SensorLibrary.VOLATILE_ORGANIC_COMPOUNDS__CONCENTRATION_PARTS_PER_MILLION,
        1,
    ],
}


class BThomeBluetoothDeviceData(BluetoothData):
    """Date for BThome Bluetooth devices."""

    def __init__(self, bindkey: bytes | None = None) -> None:
        super().__init__()
        self.bindkey = bindkey

        # Data that we know how to parse but don't yet map to the SensorData model.
        self.unhandled: dict[str, Any] = {}

        # If true, the data is encrypted
        self.is_encrypted = False

        # If true, then we know the actual MAC of the device.
        # On macOS, we don't unless the device includes it in the advertisement
        # (CoreBluetooth uses UUID's generated by CoreBluetooth instead of the MAC)
        self.mac_known = sys.platform != "darwin"

        # If true then we have used the provided encryption key to decrypt at least
        # one payload.
        # If false then we have either not seen an encrypted payload, the key is wrong
        # or encryption is not in use
        self.bindkey_verified = False

        # If this is True, then we have not seen an advertisement with a payload
        # Until we see a payload, we can't tell if this device is encrypted or not
        self.pending = True

        # The last service_info we saw that had a payload
        # We keep this to help in reauth flows where we want to reprocess and old
        # value with a new bindkey.
        self.last_service_info: BluetoothServiceInfo | None = None

    def _start_update(self, service_info: BluetoothServiceInfo) -> None:
        """Update from BLE advertisement data."""
        _LOGGER.debug("Parsing BThome BLE advertisement data: %s", service_info)
        self.set_device_manufacturer("Home Assistant")
        self.set_device_type("BThome sensor")
        for uuid, data in service_info.service_data.items():
            if self._parse_bthome(service_info, service_info.name, data):
                self.last_service_info = service_info

    def _parse_bthome(
        self, service_info: BluetoothServiceInfo, name: str, data: bytes
    ) -> bool:
        """Parser for BThome sensors"""
        mac_readable = service_info.address
        if len(mac_readable) != 17 and mac_readable[2] != ":":
            # On macOS, we get a UUID, which is useless for BThome sensors
            mac_readable = "00:00:00:00:00:00"  # noqa: F841
            return False
        source_mac = bytes.fromhex(mac_readable.replace(":", ""))

        uuid16 = service_info.service_uuids
        if uuid16 == ["0000181c-0000-1000-8000-00805f9b34fb"]:
            # Non-encrypted BThome BLE format
            payload = data
            firmware = "BThome BLE"
            packet_id = None  # noqa: F841
        elif uuid16 == ["0000181e-0000-1000-8000-00805f9b34fb"]:
            # Encrypted BThome BLE format
            try:
                payload = self._decrypt_bthome(data, source_mac)
            except TypeError:
                return False
            firmware = "BThome BLE (encrypted)"
            packet_id = parse_uint(data[-8:-4])  # noqa: F841
        else:
            return False

        if not payload:
            return False

        payload_length = len(payload)
        payload_start = 0
        result = False

        while payload_length >= payload_start + 1:
            obj_control_byte = payload[payload_start]
            obj_data_length = (obj_control_byte >> 0) & 31  # 5 bits (0-4)
            obj_data_format = (obj_control_byte >> 5) & 7  # 3 bits (5-7)
            obj_meas_type = payload[payload_start + 1]
            next_start = payload_start + 1 + obj_data_length
            if payload_length < next_start:
                _LOGGER.debug("Invalid payload data length, payload: %s", payload.hex())
                break

            if obj_data_length != 0:
                if obj_data_format <= 3:
                    if obj_meas_type in DATA_MEAS_DICT:
                        meas_data = payload[
                            payload_start + 2:next_start
                        ]  # noqa: E203
                        meas_type = DATA_MEAS_DICT[obj_meas_type][0]
                        meas_factor = DATA_MEAS_DICT[obj_meas_type][1]
                        if obj_data_format == 3:
                            meas = parse_string(meas_data)
                        else:
                            meas = dispatch[obj_data_format](meas_data, meas_factor)

                        self.update_predefined_sensor(meas_type, meas)
                        result = True
                    else:
                        _LOGGER.debug(
                            "UNKNOWN dataobject in BThome BLE payload! Adv: %s",
                            data.hex(),
                        )
                elif obj_data_format == 4:
                    # Using a different MAC address than the source mac address
                    # is not supported yet
                    data_mac = parse_mac(
                        payload[payload_start + 1:next_start]
                    )  # noqa: E203
                    if data_mac:
                        bthome_ble_mac = data_mac  # noqa: F841
                else:
                    _LOGGER.error(
                        "UNKNOWN dataobject in BThome BLE payload! Adv: %s",
                        data.hex(),
                    )
            payload_start = next_start

        if not result:
            _LOGGER.info(
                "BLE ADV from UNKNOWN BThome BLE DEVICE: MAC: %s, ADV: %s",
                to_mac(source_mac),
                data.hex(),
            )
            return False

        identifier = service_info.address
        self.set_title(f"{name} ({identifier})")
        self.set_device_name(f"{name} ({identifier})")
        self.set_device_sw_version(firmware)
        return True

    def _decrypt_bthome(self, data: bytes, bthome_mac: bytes) -> bytes | None:
        """Decrypt encrypted BThome BLE advertisements"""
        if not self.bindkey:
            self.bindkey_verified = False
            _LOGGER.debug("Encryption key not set and adv is encrypted")
            return None

        if not self.bindkey or len(self.bindkey) != 16:
            self.bindkey_verified = False
            _LOGGER.error("Encryption key should be 16 bytes (32 characters) long")
            return None

        # check for minimum length of encrypted advertisement
        if len(data) < 15:
            _LOGGER.debug("Invalid data length (for decryption), adv: %s", data.hex())

        # prepare the data for decryption
        uuid = b"\x1e\x18"
        encrypted_payload = data[:-8]
        count_id = data[-8:-4]
        mic = data[-4:]

        # nonce: mac [6], uuid16 [2], count_id [4] (6+2+4 = 12 bytes)
        nonce = b"".join([bthome_mac[::-1], uuid, count_id])
        cipher = AES.new(self.bindkey, AES.MODE_CCM, nonce=nonce, mac_len=4)
        cipher.update(b"\x11")

        # decrypt the data
        try:
            decrypted_payload = cipher.decrypt_and_verify(encrypted_payload, mic)
        except ValueError as error:
            _LOGGER.warning("Decryption failed: %s", error)
            _LOGGER.debug("mic: %s", mic.hex())
            _LOGGER.debug("nonce: %s", nonce.hex())
            _LOGGER.debug("encrypted_payload: %s", encrypted_payload.hex())
            return None
        if decrypted_payload is None:
            self.bindkey_verified = False
            _LOGGER.error(
                "Decryption failed for %s, decrypted payload is None",
                to_mac(bthome_mac),
            )
            return None
        self.bindkey_verified = True

        return decrypted_payload
